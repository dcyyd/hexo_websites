<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>网络工程师考试知识点_01</title>
    <url>https://dcyyd.github.io/hexo_websites/2024/11/23/Networking-Knowledge-Points-01/</url>
    <content><![CDATA[<h4 id="一、计算机存储与中断相关"><a href="#一、计算机存储与中断相关" class="headerlink" title="一、计算机存储与中断相关"></a><strong>一、计算机存储与中断相关</strong><span id="more"></span></h4><ol>
<li>常用的虚拟存储器由<strong>主存 - 辅存</strong>两级存储器组成。</li>
<li>中断向量可提供<strong>中断程序的入口地址</strong>。</li>
<li>DMA工作方式在<strong>主存与外设</strong>之间建立直接的数据通信。</li>
</ol>
<h4 id="二、项目管理与网络图表相关"><a href="#二、项目管理与网络图表相关" class="headerlink" title="二、项目管理与网络图表相关"></a><strong>二、项目管理与网络图表相关</strong></h4><ol>
<li>PERT不能清晰描述各个任务之间的<strong>并行情况</strong>，甘特图不能清晰描述各个问题之间的<strong>依赖关系</strong>。</li>
</ol>
<h4 id="三、网络设备与协议相关"><a href="#三、网络设备与协议相关" class="headerlink" title="三、网络设备与协议相关"></a><strong>三、网络设备与协议相关</strong></h4><ol>
<li>路由器出厂时，默认的串口封装协议是HDLC。</li>
<li>报文摘要算法生成报文摘要的目的是防止发送的报文被篡改。</li>
<li>PGP是支持电子<strong>邮件加密</strong>的协议。</li>
<li>根域名服务器采用的<strong>迭代</strong>查询。</li>
<li>中介域名服务器采用的是<strong>递归</strong>查询。</li>
<li><strong>AH隧道模式：</strong>使用AH与IP报头来封装IP数据包并对整个数据包进行签名以获得完整性并进行身份验证。</li>
<li><strong>ESP隧道模式：</strong>采用ESP与IP报头以及ESP身份验证尾端来封装IP数据包。</li>
<li><strong>L2TP数据包封装格式：</strong>IP - UDP - L2TP - PPP。</li>
<li>SNMP是在<strong>UDP</strong>协议之上的异步&#x2F;请求响应。</li>
</ol>
<h4 id="四、网络传输相关"><a href="#四、网络传输相关" class="headerlink" title="四、网络传输相关"></a><strong>四、网络传输相关</strong></h4><ol>
<li><p>支持1000m以上传输距离的是<strong>1000 BASE-Lx</strong>。</p>
</li>
<li><p><strong>nslookup参数：</strong></p>
<ul>
<li><p><strong>Set all ：</strong>列出当前设置的默认选项。</p>
</li>
<li><p><strong>Set type &#x3D; mx ：</strong>查询本地域的邮件交换器信息。</p>
</li>
<li><p><strong>Server NAME ：</strong>由当前默认服务器切换到制定的名字服务器NAME。</p>
</li>
</ul>
</li>
<li><p><strong>DNS服务器主要资源记录：</strong></p>
<ul>
<li><p><strong>A：</strong>域名到IP地址的映射。</p>
</li>
<li><p><strong>PTR：</strong>IP地址到域名的映射。</p>
</li>
<li><p><strong>MX：</strong>邮件服务器及优先级。</p>
</li>
<li><p><strong>CNAME：</strong>别名。</p>
</li>
<li><p><strong>NS：</strong>区域的授权服务器。</p>
</li>
</ul>
</li>
</ol>
<h4 id="五、结构化布线系统相关"><a href="#五、结构化布线系统相关" class="headerlink" title="五、结构化布线系统相关"></a><strong>五、结构化布线系统相关</strong></h4><ol>
<li><strong>工作区子系统：</strong>由终端设备到信息插座的整个区域，用于将用户终端设备连接到布线系统，主要包括信息插座、跳线、适配器。</li>
<li><strong>水平布线子系统：</strong>是结构化综合布线系统中连接用户工作区与布线系统主干的子系统。</li>
<li><strong>管理子系统：</strong>是结构化布线系统中对布线电缆进行端接及配线管理的子系统，通常设置在楼层的接线间内。</li>
<li><strong>干线子系统：</strong>是结构化综合布线系统中连接各管理间、设备间的子系统，又称垂直子系统。</li>
<li><strong>设备间子系统：</strong>主要是用来安放网络关键设备。并非每一个综合布线都有设备间子系统。</li>
<li><strong>建筑群子系统：</strong>是结构化综合布线系统中由连接楼群之间的通信传输介质及各种支持设备组成的子系统。</li>
</ol>
<h4 id="六、xDSL相关"><a href="#六、xDSL相关" class="headerlink" title="六、xDSL相关"></a><strong>六、xDSL相关</strong></h4><ol>
<li><strong>HDSL：</strong>中断距离可达3 - 5KM、传输速率2.048Mbits&#x2F;s。</li>
<li><strong>ADSL：</strong>是一种非对称的DSL技术。</li>
<li><strong>VDSL：</strong>是一种非对称的技术，也是DSL中传输速度最快的技术。</li>
<li><strong>SDSL：</strong>单线路数字用户技术是对称的。</li>
<li><strong>RADSL：</strong>速率自适应数字用户线技术，是采用非对称技术。</li>
</ol>
<h4 id="七、私有地址相关"><a href="#七、私有地址相关" class="headerlink" title="七、私有地址相关"></a><strong>七、私有地址相关</strong></h4><ol>
<li><strong>A类：</strong>10.0.0.0 - 10.255.255.255。</li>
<li><strong>B类：</strong>172.16.0.0 - 172.31.255.255。</li>
<li><strong>C类：</strong>192.168.0.0 - 192.168.255.255。</li>
</ol>
<h4 id="八、阻止路由环路相关"><a href="#八、阻止路由环路相关" class="headerlink" title="八、阻止路由环路相关"></a><strong>八、阻止路由环路相关</strong></h4><ol>
<li><p><strong>最大跳计数（Maximum Hop Count）</strong></p>
<ul>
<li><strong>原理：</strong><ul>
<li>在许多路由协议（如 RIP）中，会为数据包经过的路由器数量设置一个最大值。例如，RIP 协议默认的最大跳数是 15。当一个数据包经过的路由器数量达到这个最大值时，该数据包将被丢弃。这是因为随着跳数的不断增加，网络环路的可能性也在增大。如果没有最大跳数的限制，数据包可能会在网络中无限循环，消耗网络资源。</li>
</ul>
</li>
<li><strong>示例：</strong><ul>
<li>假设有一个简单的网络拓扑，包括路由器 A、B、C、D 和 E，它们之间通过链路相连。如果一个数据包从路由器 A 出发，经过 B、C、D、E，然后又回到 A，并且这个过程不断循环，没有最大跳数限制，这个数据包就会一直在这个环路中传递。但如果设置了最大跳数为 5，当数据包经过 5 个路由器后，就会被丢弃，从而防止了无限循环。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>水平分割（Split Horizon）</strong></p>
<ul>
<li><strong>原理：</strong><ul>
<li>水平分割规则规定，从一个接口学到的路由信息不会再从这个接口发送出去。这样可以避免路由器将从某个邻居学到的路由信息又发送回给这个邻居，从而防止产生路由环路。它基于一个简单的逻辑，即如果路由器已经从某个方向学到了到达某个网络的路由，那么它不应该再向这个方向通告这个路由，因为这个方向的邻居很可能就是通过它才学到这个路由的。</li>
</ul>
</li>
<li><strong>示例：</strong><ul>
<li>假设路由器 R1 和 R2 是邻居，它们之间通过接口 E0 相连。R1 通过接口 E0 向 R2 通告了到达网络 N 的路由。根据水平分割规则，R2 不会再通过接口 E0 向 R1 通告到达网络 N 的路由。这样就避免了 R1 和 R2 之间可能产生的路由环路。例如，在一个帧中继网络中，多个路由器通过虚电路相连，水平分割可以有效地防止路由信息在相邻路由器之间的来回传递，避免环路的形成。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>路由毒化（Route Poisoning）</strong></p>
<ul>
<li><strong>原理：</strong><ul>
<li>当一个路由不可达时，路由器会将该路由标记为不可达（通常将其度量值设置为无穷大），并且向相邻路由器通告这个不可达信息。相邻路由器收到这个中毒的路由信息后，会更新自己的路由表，并且也会向它的相邻路由器通告这个不可达信息。这样，网络中的所有路由器都会快速地知道这个路由已经不可达，从而避免将数据包转发到这个不可达的路径上，防止了路由环路的产生。</li>
</ul>
</li>
<li><strong>示例：</strong><ul>
<li>比如在一个网络中有路由器 A、B、C。路由器 A 发现它到网络 X 的链路出现故障，它就会将到网络 X 的路由标记为不可达（如将跳数设置为 16，在 RIP 协议中表示不可达），并向路由器 B 通告这个中毒的路由。路由器 B 收到后更新自己的路由表，然后也向路由器 C 通告这个中毒的路由。这样，整个网络就会很快知道网络 X 不可达，避免了因为链路故障而可能导致的数据包在 A - B - C - A 这样的环路中转发。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>保持关闭（Hold - down）</strong></p>
<ul>
<li><p><strong>原理</strong></p>
<p>：</p>
<ul>
<li>当路由器从邻居收到一个路由不可达的消息后，它会进入一个保持关闭状态。在这个状态下，路由器会忽略来自同一个邻居的关于这条路由的任何更新信息（通常会持续一段时间，如 180 秒）。这是因为在网络不稳定的情况下，可能会出现错误的路由更新信息。例如，当一条链路刚刚出现故障时，可能会因为网络的收敛过程而产生一些错误的更新，导致路由器错误地更新路由表，进而产生路由环路。保持关闭机制可以让路由器在一段时间内不被这些可能错误的更新所干扰，等待网络稳定后再更新路由表。</li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<ul>
<li>假设路由器 R1 收到来自邻居 R2 的消息，说到达网络 Y 的路由不可达。R1 进入保持关闭状态。如果在这个状态期间，R2 又发送了一个关于网络 Y 的更新（可能是由于网络波动，这个更新是错误的），R1 会忽略这个更新。只有当保持关闭时间结束后，R1 才会考虑来自 R2 的关于网络 Y 的更新，这样就避免了在网络不稳定时，因为错误的更新而导致的路由环路。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="九、链路状态通告相关"><a href="#九、链路状态通告相关" class="headerlink" title="九、链路状态通告相关"></a><strong>九、链路状态通告相关</strong></h4><ol>
<li><strong>链路状态通告（LSA - Link - State Advertisement）的定义与作用：</strong><ul>
<li>链路状态通告是链路状态路由协议（如 OSPF、IS - IS）中的关键元素。它是一种包含了路由器自身以及其直连链路信息的数据包。这些信息包括接口的 IP 地址、子网掩码、链路的开销（cost）、链路的连接状态（是 up 还是 down）等。路由器通过在网络中泛洪 LSA，使得网络中的其他路由器能够了解整个网络的拓扑结构。</li>
<li>例如，在一个企业网络中，使用 OSPF 协议。路由器 A 通过生成 LSA 来通告自己的接口连接到网络 192.168.1.0&#x2F;24，开销为 10，并且接口状态是 up。这个 LSA 会在网络中传播，让其他路由器知道如何到达这个网络以及相关的链路成本。</li>
</ul>
</li>
<li><strong>LSA 的内容构成：</strong><ul>
<li><strong>路由器标识符（Router ID）：</strong><ul>
<li>这是一个用于唯一标识路由器的编号。在 OSPF 中，通常是路由器上最大的活动接口的 IP 地址，或者可以手动配置。它用于区分不同的路由器发送的 LSA。例如，在一个有多个路由器的网络中，路由器 A 的 Router ID 为 1.1.1.1，路由器 B 的 Router ID 为 2.2.2.2，这样其他路由器就可以根据 Router ID 来识别 LSA 的来源。</li>
</ul>
</li>
<li><strong>链路类型（Link Type）：</strong><ul>
<li>描述了路由器与其他设备之间链路的性质。常见的链路类型包括点到点链路（如两个路由器之间通过串行接口直接相连）、广播链路（如连接到以太网段）和非广播多路访问（NBMA，例如帧中继网络）。不同的链路类型在 LSA 中会有不同的表示方式，并且会影响路由计算和数据包转发。例如，在广播链路中，路由器需要选举出一个指定路由器（DR）和备份指定路由器（BDR）来管理 LSA 的泛洪过程。</li>
</ul>
</li>
<li><strong>链路开销（Link Cost）：</strong><ul>
<li>代表了通过该链路传输数据的代价。开销的计算可以基于链路的带宽、延迟等因素。例如，一条 100Mbps 的以太网链路的开销可能比一条 10Mbps 的以太网链路的开销小。开销是用于计算最短路径的重要参数，路由器会根据收到的 LSA 中的开销信息来选择到达目标网络的最优路径。</li>
</ul>
</li>
<li><strong>邻居信息（Neighbor Information）：</strong><ul>
<li>列出了与该路由器直接相连的其他路由器的标识符（如 Router ID）。这有助于构建完整的网络拓扑图。例如，路由器 A 在 LSA 中列出它的邻居是路由器 B 和路由器 C，它们的 Router ID 分别为 2.2.2.2 和 3.3.3.3，这样其他路由器收到这个 LSA 后，就可以知道路由器 A 与哪些路由器相连。</li>
</ul>
</li>
</ul>
</li>
<li><strong>LSA 的泛洪过程（Flooding）：</strong><ul>
<li>当路由器生成一个新的 LSA 或者收到一个更新的 LSA 时，它会将这个 LSA 发送给除了接收该 LSA 的接口之外的所有接口。这个过程称为泛洪。例如，在一个由多个路由器组成的网状网络中，路由器 A 生成了一个新的 LSA，它会将这个 LSA 发送给与它相连的路由器 B、C 和 D。路由器 B 收到这个 LSA 后，会检查自己的链路状态数据库（LSDB），如果这个 LSA 是新的或者比自己已有的 LSA 更新（根据序列号、校验和等信息判断），它会将这个 LSA 存储到自己的 LSDB 中，然后再向它的其他邻居（除了发送这个 LSA 给它的路由器 A）泛洪这个 LSA。这个过程会一直持续，直到网络中的所有路由器都收到并存储了这个最新的 LSA。</li>
<li>在这个过程中，为了防止 LSA 在网络中无限循环，每个 LSA 都有一个序列号。路由器通过比较序列号来判断 LSA 的新旧。当一个 LSA 的序列号达到最大值后，会重新从初始值开始，但同时会有其他机制（如老化时间）来确保 LSA 的准确性和及时性。</li>
</ul>
</li>
<li><strong>LSA 的老化与更新：</strong><ul>
<li><strong>老化（Aging）：</strong><ul>
<li>LSA 有一个老化时间，通常在 OSPF 中是 30 分钟。从 LSA 产生开始计算时间，当老化时间到期后，这个 LSA 会被标记为无效。这是为了确保网络拓扑信息的及时性。如果网络拓扑发生变化，旧的 LSA 不应该一直存在于网络中影响路由决策。例如，一个路由器的接口连接的网络被重新划分了子网，旧的 LSA 中关于这个网络的信息就需要更新，老化机制可以促使这种更新。</li>
</ul>
</li>
<li><strong>更新（Update）：</strong><ul>
<li>当路由器的链路状态发生变化时（如接口的状态从 up 变为 down，或者链路的开销发生变化），它会生成一个新的 LSA 来更新网络中的其他路由器。这个新的 LSA 会包含更新后的链路信息，并且会按照泛洪过程在网络中传播。例如，路由器 A 和路由器 B 之间的链路带宽从 10Mbps 提升到 100Mbps，路由器 A 会更新关于这条链路的 LSA，将链路开销等信息更新后，在网络中泛洪这个新的 LSA，让其他路由器知道网络拓扑的这个变化。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="十、VTP、STP及ACL相关"><a href="#十、VTP、STP及ACL相关" class="headerlink" title="十、VTP、STP及ACL相关"></a><strong>十、VTP、STP及ACL相关</strong></h4><ol>
<li><p><strong>访问控制列表的分类：</strong></p>
<ul>
<li><strong>标准访问控制列表：</strong>主要基于源 IP 地址进行过滤，通常使用的编号范围是 1 - 99 以及 1300 - 1999（不同的 IOS 版本可能略有差异）。它的功能相对较为基础，只能对数据包的源 IP 地址进行匹配判断，进而决定是否允许该数据包通过。</li>
<li><strong>扩展访问控制列表：</strong>功能更强大，可以基于源 IP 地址、目的 IP 地址、协议类型、端口号等多种条件来进行过滤，编号范围一般是 100 - 199 以及 2000 - 2699。通过综合考虑多个因素，能实现更精细、更复杂的访问控制策略。</li>
</ul>
</li>
<li><p><strong>具体 ACL 语句分析：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）Access-list 10 deny host 10.37.168.137 与 access-list 10 deny 10.37.168.137 等价，拒绝任何来自 10.23.168.137 的分组。</span><br><span class="line">（2）Any 与 0.0.0.0 255.255.255.255 等价，表示整个 IP 地址范围。</span><br><span class="line">（3）Access-list 10 deny tcp any (源地址) host 172.16.30.2 (目的地址) eq 23/telnet ：禁止任何主机访问 10.37.16.30.2 的 telnet 服务。</span><br><span class="line">（4）Access-list 110 permit tcp host 192.168.177.2 host 172.22.89.26 eq www/80 ，允许源 IP 地址为 192.168.177.2 的主机，通过 TCP 协议访问目的 IP 地址为 172.22.89.26 的主机的 80 端口。</span><br><span class="line">（5）Access-list 110 deny tcp any host 172.22.89.26 eq 80 ，只允许指定的 192.168.177.2 访问该主机的 80 端口。</span><br><span class="line">（6）Access-list 110 permit ip any any ，放行其他所有流量。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>接口应用 ACL 规则：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Interface S0</span><br><span class="line">Ip access-group 110 out</span><br><span class="line">允许 192.168.177.2 以 http 方式访问主机 172.22.89.26，但是拒绝其他主机的数据流访问 172.22.89.26 的 web 服务（80 端口）。</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="十一、NAT相关："><a href="#十一、NAT相关：" class="headerlink" title="十一、NAT相关："></a><strong>十一、NAT相关：</strong></h4><ol>
<li><p><strong>NAT（网络地址转换）分类：</strong></p>
<ul>
<li><p><strong>静态 NAT：</strong>内部本地地址和内部全局地址进行一对一的永久映射。</p>
<ul>
<li><p>示例配置（以 Cisco 路由器为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 定义内部本地地址和内部全局地址的映射关系：</span><br><span class="line">Router(config)#ip nat inside source static 192.168.1.2 209.165.200.22</span><br><span class="line"># 指定内部接口和外部接口：</span><br><span class="line">Router(config)#interface FastEthernet0/0</span><br><span class="line">Router(config - if)#ip nat inside</span><br><span class="line">Router(config - if)#interface Serial0/0/0</span><br><span class="line">Router(config - if)#ip nat outside</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>动态 NAT：</strong>从一个内部全局地址池中动态地分配地址给内部本地地址（临时映射关系）。</p>
<ul>
<li><p>示例配置（以 Cisco 路由器为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入全局配置模式：</span><br><span class="line">Router#conf t</span><br><span class="line"># 定义内部全局地址池。假设地址池名为 POOL1，包含的地址范围是 209.165.200.20 - 209.165.200.30：</span><br><span class="line">Router(config)#ip nat pool POOL1 209.165.200.20 209.165.200.30 netmask 255.255.255.0</span><br><span class="line"># 定义访问控制列表（ACL）来指定哪些内部本地地址可以进行 NAT 转换。假设允许 192.168.1.0/24 网段的主机进行 NAT 转换：</span><br><span class="line">Router(config)#access - list 1 permit 192.168.1.0 0.0.0.255</span><br><span class="line"># 将 ACL 与地址池关联，实现动态 NAT：</span><br><span class="line">Router(config)#ip nat inside source list 1 pool POOL1</span><br><span class="line"># 指定内部接口和外部接口（同静态 NAT）：</span><br><span class="line">Router(config)#interface FastEthernet0/0</span><br><span class="line">Router(config - if)#ip nat inside</span><br><span class="line">Router(config - if)#interface Serial0/0/0</span><br><span class="line">Router(config - if)#ip nat outside</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>配置 PAT（NAT 重载，也叫端口地址转换）：</strong></p>
<ul>
<li><p><strong>原理</strong>：PAT 通过使用不同的端口号来区分不同的内部本地地址的连接，使得多个内部本地地址可以共享一个或少数几个内部全局地址。这样可以更有效地利用 IP 地址资源，是一种多对一的地址转换方式。</p>
</li>
<li><p>示例配置（以 Cisco 路由器为例）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入全局配置模式：</span><br><span class="line">Router(config)#conf t</span><br><span class="line"># 定义访问控制列表（ACL）来指定哪些内部本地地址可以进行 NAT 转换。假设允许 192.168.1.0/24 网段的主机进行 NAT 转换：</span><br><span class="line">Router(config)#access - list 1 permit 192.168.1.0 0.0.0.255</span><br><span class="line"># 将 ACL 与外部接口关联，实现 PAT。假设外部接口是 Serial0/0/0：</span><br><span class="line">Router(config)#ip nat inside source list 1 interface Serial0/0/0 overload</span><br><span class="line"># 指定内部接口和外部接口（同静态 NAT）：</span><br><span class="line">Router(config)#interface FastEthernet0/0</span><br><span class="line">Router(config - if)#ip nat inside</span><br><span class="line">Router(config - if)#interface Serial0/0/0</span><br><span class="line">Router(config - if)#ip nat outside</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="十二、无线网络相关："><a href="#十二、无线网络相关：" class="headerlink" title="十二、无线网络相关："></a><strong>十二、无线网络相关：</strong></h4><ol>
<li><p><strong>IEEE802.11标准：</strong></p>
<ul>
<li><p>IEEE802.11a：54Mbits&#x2F;s 、5GHz标准。</p>
</li>
<li><p>IEEE802.11b：对802.11的改进，以支持5.5.Mbits&#x2F;s和11Mbits&#x2F;s。</p>
</li>
<li><p>IEEE892.11g：54Mbits&#x2F;s、2.4GHz标准（向后兼容802.11b）。</p>
</li>
<li><p>IEEE892.11n：使用MIMO(多入多出天线)提高吞吐量。</p>
</li>
<li><p>Wi-fi联盟认可了802.11i标准，并称之为wap2。</p>
</li>
<li><p>Wap2使用了aes-ccmp机密技术。</p>
</li>
</ul>
</li>
</ol>
<h4 id="十三、IPv6相关："><a href="#十三、IPv6相关：" class="headerlink" title="十三、IPv6相关："></a><strong>十三、IPv6相关：</strong></h4><ol>
<li><p><strong>特殊IPv6地址：</strong></p>
<ul>
<li><p>0:0:0:0:0:0:0:0(::) 相当于IPv4地址0.0.0.0，通常在使用有状态DHCP配置时，用作主机的源地址。</p>
</li>
<li><p>0:0:0:0:0:0:0:1(::1) 相当于IPv4地址127.0.0.1。</p>
</li>
<li><p>0:0:0:0:0:0:192.168.100.1 在同时支持IPv4和IPv6的网络中，从IPv4地址转换而来的IPv6地址通常这样写。</p>
</li>
</ul>
</li>
<li><p><strong>IPv6地址类型：</strong></p>
<ul>
<li><p>2000::&#x2F;3全局单播地址。</p>
</li>
<li><p>FC00::&#x2F;7唯一的本地单播地址范围。</p>
</li>
<li><p>FE80::&#x2F;10链路本地单播地址范围。</p>
</li>
<li><p>FF00::&#x2F;8组播地址范围 。</p>
</li>
<li><p>2001:0DB8::&#x2F;32保留举例和编写文档时使用。</p>
</li>
<li><p>3FFF:FFFF::&#x2F;32 保留举例和编写文档时使用。</p>
</li>
<li><p>2002::&#x2F;16 保留供6to4隧道技术使用。</p>
</li>
</ul>
</li>
</ol>
<h4 id="十四、软件设计相关："><a href="#十四、软件设计相关：" class="headerlink" title="十四、软件设计相关："></a><strong>十四、软件设计相关：</strong></h4><p>在软件设计阶段，划分模块的原则是一个模块的控制范围应该在作用范围之内。</p>
<ol>
<li><strong>模块的控制范围和作用范围的定义：</strong><ul>
<li><strong>控制范围：</strong>是指模块本身及其所有下属模块（如果有）的集合。</li>
<li><strong>作用范围：</strong>是指受该模块内一个判定影响的所有其他模块的集合。</li>
</ul>
</li>
<li><strong>为什么控制范围应该在作用范围之内：</strong><ul>
<li><strong>可维护性：</strong>模块控制范围在作用范围内，当需对软件进行维护或修改时，开发人员可以很容易地确定修改一个模块可能会影响到哪些其他模块。</li>
<li><strong>可读性和理解性</strong>：这种原则有助于提高软件设计的可读性和理解性。</li>
<li><strong>降低耦合度</strong>：使得模块之间的耦合度降低。</li>
</ul>
</li>
</ol>
<h4 id="十五、软件项目活动图相关："><a href="#十五、软件项目活动图相关：" class="headerlink" title="十五、软件项目活动图相关："></a><strong>十五、软件项目活动图相关：</strong></h4><p>软件项目活动图中，松弛时间表示在不影响整个工作的前提下，完成该项任务有多少机动余地，松弛时间为0的任务构成了完成整个工程的关键任务，即所需时间最长的任务。</p>
<h4 id="十六、其他网络概念相关"><a href="#十六、其他网络概念相关" class="headerlink" title="十六、其他网络概念相关"></a><strong>十六、其他网络概念相关</strong></h4><ol>
<li><p><strong>VPI与CIR：</strong>VPI用来表示不同虚拟路径，CIR用来约束数据速率。</p>
</li>
<li><p><strong>代理ARP：</strong>是指由离目标主机最近的交换机假装目标主机回答源主机的ARP请求。</p>
</li>
<li><p><strong>距离矢量路由协议：</strong>每一个路由器接收的路由信息来源于它的邻居路由器。</p>
</li>
<li><p><strong>BGP4协议：</strong></p>
<ul>
<li><p>打开（open）报文建立两个路由之间的邻居关系。</p>
</li>
<li><p>更新（UPDATE）报文给出了新的路由信息。</p>
</li>
</ul>
</li>
<li><p><strong>OSPF协议：</strong></p>
<ul>
<li><p>链路状态算法用于计算路由表。</p>
</li>
<li><p>一个路由器的链路状态只涉及与相邻路由器的连通状态。</p>
</li>
</ul>
</li>
<li><p><strong>组播地址：</strong></p>
<ul>
<li><p>224.0.0.0 - 224.0.0.255为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其他地址供路由协议用。</p>
</li>
<li><p>224.0.1.0 - 224.0.1.255是公用组播地址，可以用于Internet。</p>
</li>
<li><p>224.0.2.0 - 238.255.255.255可为用户可用的组播地址（临时组播地址），全网范围内有效。</p>
</li>
<li><p>239.0.0.0 - 239.255.255.255为本地管理组地址，仅在特定的本地范围内有效。</p>
</li>
<li><p>组播服务发送信息只需要发送一个分组，组内所有成员即可全部收到。</p>
</li>
</ul>
</li>
<li><p><strong>数字签名验证：</strong>用户B收到用户A带数字签名的消息M，为了验证M的真实性，首先需要从CA获取用户的数字证书，并利用CA的公钥验证证书的真伪，然后利用A的公钥验证M的真实性。</p>
</li>
<li><p><strong>SDES算法</strong>：是一种共享秘钥算法。</p>
</li>
<li><p><strong>IPSEC安全关联：</strong>IPSEC中安全关联（security Associations）三元组是&lt;安全参数索引SPI，目标IP地址，安全协议&gt;。</p>
</li>
<li><p><strong>SNMP协议：</strong>当代理收到一个GET请求时，如果有一个值不可或者不能提供，则返回该实例的下一个值。</p>
</li>
<li><p><strong>SNMP网络管理：</strong>一个代理可以由多个管理站管理。</p>
</li>
<li><p><strong>自动专用IP地址：</strong></p>
<ul>
<li><p>用途是DHCP服务器的专用地址。</p>
</li>
<li><p>自动专用IP地址的范围是169.254.0.0 - 169.254.255.255。</p>
</li>
</ul>
</li>
<li><p><strong>以太网结构填充字段：</strong>作用是保持最小帧长。</p>
</li>
<li><p><strong>物联网无线传感网络技术</strong>：是802.15.3ZigBee微微网。</p>
</li>
<li><p><strong>4G标准：</strong>LTE、LTE-Advanced、WIMAXII、Wireless MAN、UMB等属于4G标准。</p>
</li>
<li><p><strong>扩展频谱通信：</strong>主要思想是将信号散步到更宽的带宽上以减少阻塞和干扰的机会。</p>
</li>
<li><p><strong>CLOSE-WAIT状态：</strong>等待从本地用户发来的连接中断请求。</p>
</li>
<li><p><strong>BGP报文：</strong></p>
<ul>
<li><p>Open报文：用于建立邻居关系。</p>
</li>
<li><p>Update报文：用于发送新的路由信息。</p>
</li>
<li><p>Keepalive报文：用于对Open的应答和周期性地确认邻居关系。</p>
</li>
<li><p>Notification报文：用于报告监测到的错误。</p>
</li>
</ul>
</li>
<li><p><strong>Vsftp服务：</strong>可以通过 service Vsftpd start&#x2F;down&#x2F;restart 三个命令来启动、关闭和重启，主配置文件名为 vsftpd.conf 。</p>
</li>
<li><p><strong>SNMP团体名设置：</strong></p>
<ul>
<li><p>R2(config)#snmp-server community publicr  ro ：设置snmp-server的只读团体名为publicr。</p>
</li>
<li><p>R2(config)# snmp-server community publicw  rw ：设置snmp-server的读写团体名为publicw。</p>
</li>
<li><p>Nat(inside) 1 0 或者 nat(inside) 1.0.0.0 0.0.0.0 表示内网的所有主机均可以访问外网。</p>
</li>
</ul>
</li>
<li><p><strong>华为静态路由与默认路由配置：</strong></p>
<ol>
<li><p><strong>静态路由配置：</strong></p>
<ul>
<li><p><strong>配置基本静态路由：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt;system - view  # 进入系统视图，这是配置大多数华为设备命令的前提操作，后续配置都在此视图下进行</span><br><span class="line">[Huawei]ip route - static 192.168.2.0 255.255.255.0 192.168.1.2  # 配置一条静态路由</span><br><span class="line"># “ip route-static”是配置静态路由的命令关键字</span><br><span class="line"># “192.168.2.0”是目的网络地址，表示要去往的目标网络段</span><br><span class="line"># “255.255.255.0”是对应的子网掩码，用于精确界定目的网络的范围</span><br><span class="line"># “192.168.1.2”是下一跳地址，也就是数据包从本路由器发出去后，下一个接收该数据包的设备接口地址</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置负载分担的静态路由（多条链路到同一目的网络）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Huawei]ip route - static 10.0.0.0 255.0.0.0 172.16.1.2  # 配置第一条到达目的网络10.0.0.0/8的静态路由</span><br><span class="line"># 这条命令含义与上面基本静态路由类似，这里目的网络是10.0.0.0，子网掩码255.0.0.0，下一跳为172.16.1.2，用于和下一条命令共同实现负载分担</span><br><span class="line">[Huawei]ip route - static 10.0.0.0 255.0.0.0 172.16.2.2  # 配置第二条到达目的网络10.0.0.0/8的静态路由</span><br><span class="line"># 同样是去往10.0.0.0/8网络，但下一跳变为172.16.2.2，两条链路可同时分担去往该目的网络的流量，实现负载分担功能</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态路由的优先级调整：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Huawei]ip route - static 10.0.0.0 255.0.0.0 172.16.1.2 preference 70  # 调整特定静态路由的优先级</span><br><span class="line"># “preference”关键字用于设置优先级，此处将之前配置的去往10.0.0.0/8网络且下一跳为172.16.1.2的静态路由优先级设置为70</span><br><span class="line"># 优先级数值越大，表示该路由相对其他到达相同目的网络的路由被优先选用的程度越低，默认静态路由优先级是60</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>默认路由配置：</strong></p>
<ul>
<li><p><strong>配置基本默认路由：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Huawei]ip route - static 0.0.0.0 0.0.0.0 192.168.1.1  # 配置默认路由</span><br><span class="line"># “0.0.0.0 0.0.0.0”表示所有网络（目的网络地址和子网掩码都为全0），意味着如果数据包的目的地址在本地路由表中没有更精确匹配的路由条目时，都将按照这条默认路由转发</span><br><span class="line"># “192.168.1.1”是下一跳地址，即数据包将被转发到这个地址对应的设备接口</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置默认路由的应用场景示例（完整配置）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt;system - view  # 进入系统视图</span><br><span class="line">[Huawei]interface GigabitEthernet0/0/1  # 进入路由器的一个接口（假设是连接内部网络的接口）视图，GigabitEthernet0/0/1是接口名称，可根据实际设备接口情况改变</span><br><span class="line">[Huawei - GigabitEthernet0/0/1]ip address 192.168.1.254 255.255.255.0  # 配置该接口的IP地址为192.168.1.254，子网掩码为255.255.255.0，使其能与内部网络通信</span><br><span class="line">[Huawei - GigabitEthernet0/0/1]quit  # 退出接口视图，回到系统视图</span><br><span class="line">[Huawei]interface GigabitEthernet0/0/2  # 进入另一个接口（假设是连接外部网络，比如ISP的接口）视图</span><br><span class="line">[Huawei - GigabitEthernet0/0/2]ip address 202.100.1.2 255.255.255.252  # 配置该接口的IP地址为202.100.1.2，子网掩码为255.255.255.252，使其能与外部网络通信</span><br><span class="line">[Huawei - GigabitEthernet0/0/2]quit  # 退出接口视图，回到系统视图</span><br><span class="line">[Huawei]ip route - static 0.0.0.0 0.0.0.0 202.100.1.1  # 配置默认路由，下一跳地址为202.100.1.1，这样内部网络的数据可以通过这个接口转发出去访问互联网等外部网络</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>运算器：</strong>主要完成算术运算、逻辑运算和移位操作，主要部件有算术逻辑单元（ALU）、累加器（ACC）、标志寄存器、寄存器组、多路转换器、数据总线等。</p>
</li>
<li><p><strong>控制器：</strong>主要实现指令的读入、寄存、译码和执行过程有序地发出控制信号。控制器主要由指令寄存器、程序计数器、指令译码器、状态&#x2F;条件寄存器、时序产生器、微操作信号发生器组成。</p>
</li>
<li><p><strong>地址映射方式：</strong>有：全相联方式、直接方式和组相联方式。</p>
</li>
<li><p><strong>专利保护期限：</strong>根据我国《专利法》规定，发明专利的保护期限为20年，实用型和外观设计专利为10年。</p>
</li>
<li><p><strong>交换机与路由器连接：</strong>交换机与路由器用直通电缆连接。</p>
</li>
<li><p><strong>默认静态路由配置：</strong>例如： Router(config)#ip route 0.0.0.0 0.0.0.0 [exit-interface | ip-address ] 。</p>
</li>
<li><p><strong>cache与内存转换：</strong>cache与内存之间的转换是由硬件完成的。</p>
</li>
<li><p><strong>相联存储器：</strong>按内容方式访问。</p>
</li>
<li><p><strong>E1、E2、E3、T1载波数据速率：</strong></p>
<ul>
<li><p>E1载波的数据速率为2.048Mbit&#x2F;s。</p>
</li>
<li><p>E2由4个E1组成。</p>
</li>
<li><p>E3由4个E2组成。</p>
</li>
<li><p>T1载波的数据速率为1.544Mbit&#x2F;s。</p>
</li>
</ul>
</li>
<li><p>**<code>route print</code><strong>与</strong><code>netstat –r</code>**功能是一样的。</p>
</li>
<li><p>在Linux中，DNS服务器的配置文件为<code>/etc/resolv.conf</code>。</p>
</li>
<li><p>MD5算法属于<strong>摘要算法</strong>。</p>
</li>
<li><p><strong>集成windows身份验证</strong>是安全级别最高的验证方法。</p>
</li>
<li><p><strong>网络可用性</strong>是指用户可利用网络时间得百分比。</p>
</li>
<li><p><strong>网络管理功能：</strong>网络管理的5大功能为：配置管理、故障管理、计费管理、性能管理和安全管理。</p>
</li>
<li><p><strong>BGP传输协议及端口：</strong>BGP将TCP用作其传输协议，运行在TCP的179端口上（目的端口）。</p>
</li>
<li><p><strong>BGP邻居关系维持：</strong>BGP使用keepalive周期性的发送存活消息（60s）维持邻居关系。</p>
</li>
<li><p><strong>IPsec传输模式选择：</strong>IPsec传输模式和隧道模式，实现端到端的传输应选择传输模式。</p>
</li>
<li><p><strong>IPv6地址类型：</strong>IPv6地址分为3中类型，它们是单播地址、组播地址、任意播地址。</p>
</li>
<li><p><strong>802.11 MAC层算法：</strong>802.11在MAC层采用了CSMA&#x2F;CA算法。</p>
</li>
<li><p><strong>Ieee802.11n数据速率：</strong>Ieee802.11n提供的最高数据速率可达到300Mbit&#x2F;s。</p>
</li>
<li><p><strong>IEEE802.16标准：</strong>IEEE802.16工作组提出的无线接入系统空中接口标准是WiMAX。</p>
</li>
<li><p><strong>安全电子邮件协议：</strong>安全电子邮件使用PGP协议。</p>
</li>
<li><p>Linux服务器中DHCP服务器程序对应的配置文件的名称为<code>dhcp.conf</code>，该文件的默认目录是<code>/etc</code>。</p>
</li>
<li><p><strong>CSMA&#x2F;CD（载波监听多路访问 &#x2F; 碰撞检测）算法：</strong></p>
<ul>
<li><strong>基本原理：</strong><ul>
<li>CSMA&#x2F;CD 主要用于解决在共享介质的以太网中，多个节点同时访问介质时可能产生的冲突问题。其工作过程主要包括载波监听、冲突检测和退避。</li>
<li>当一个节点要发送数据时，首先会进行载波监听，也就是检测信道是否空闲。如果信道空闲，节点就开始发送数据；如果信道忙，则节点会等待，直到信道空闲。</li>
</ul>
</li>
<li><strong>冲突检测机制：</strong><ul>
<li>在发送数据过程中，节点同时进行冲突检测。这是因为电磁波在介质中传播需要时间，即使在发送数据时检测到信道空闲，但在数据传输过程中仍有可能与其他节点发送的数据发生冲突。</li>
<li>节点通过比较自己发送的数据信号和从信道上接收到的信号来判断是否发生冲突。如果发现信号不同，就表示发生了冲突。</li>
</ul>
</li>
<li><strong>退避算法：</strong><ul>
<li>一旦检测到冲突，发送节点会立即停止发送数据，并执行退避算法。退避算法的目的是让发生冲突的节点在不同的时间重新尝试发送数据，以减少再次冲突的可能性。</li>
<li>常用的退避算法是二进制指数退避算法。在这种算法中，冲突次数 n 决定了节点重新发送数据前需要等待的时间间隔。等待时间间隔的计算公式为，其中是一个在区间均匀分布的随机数，是一个与网络参数相关的常量（如时隙时间）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>监听算法分类：</strong></p>
<ul>
<li><strong>非坚持 CSMA（Non - persistent CSMA）：</strong><ul>
<li><strong>工作原理：</strong><ul>
<li>当一个节点要发送数据时，首先监听信道。如果信道空闲，就立即发送数据；如果信道忙，则不再继续监听，而是随机等待一段时间后，再重新监听信道是否空闲。</li>
</ul>
</li>
<li><strong>特点：</strong><ul>
<li>这种算法的优点是减少了节点等待信道空闲的时间，因为一旦发现信道忙就不再监听，而是等待一段时间后重新尝试。缺点是如果有多个节点同时等待发送数据，可能会导致频繁的冲突，因为它们重新开始监听的时间是随机的，很可能再次同时发现信道空闲而同时发送数据。</li>
</ul>
</li>
</ul>
</li>
<li>1 - 坚持 CSMA（1 - persistent CSMA）<ul>
<li>工作原理<ul>
<li>当节点要发送数据时，首先监听信道。如果信道空闲，就立即发送数据；如果信道忙，则持续监听，直到信道空闲后立即发送数据。</li>
</ul>
</li>
<li>特点<ul>
<li>优点是只要信道空闲，节点就能很快地发送数据，减少了等待时间。缺点是如果有两个或多个节点同时等待发送数据，当信道空闲时，它们会同时发送数据，导致冲突概率较高。</li>
</ul>
</li>
</ul>
</li>
<li>P - 坚持 CSMA（P - persistent CSMA）<ul>
<li>工作原理<ul>
<li>用于时分复用的信道。当节点要发送数据时，首先监听信道。如果信道空闲，就以概率发送数据，以概率推迟发送；如果信道忙，则持续监听，直到信道空闲后，再按照上述概率规则发送数据。</li>
</ul>
</li>
<li>特点<ul>
<li>这种算法试图在非坚持 CSMA 和 1 - 坚持 CSMA 之间找到一个平衡。当时，它就变成了 1 - 坚持 CSMA；当时，它就变成了非坚持 CSMA。但是，它的实现相对复杂，而且要选择合适的值才能有效地降低冲突概率。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>IEEE802.3最小帧长：</strong>IEEE802.3规定的最小帧长为64字节。</p>
</li>
<li><p>Apache的主配置文件名是<code>http.conf</code>，改文件所在所在目录为<code>/etc</code>。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>网工</category>
      </categories>
      <tags>
        <tag>网络工程师</tag>
        <tag>考试知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>网络工程师考试知识点_02</title>
    <url>https://dcyyd.github.io/hexo_websites/2024/11/24/Networking-Knowledge-Points-02/</url>
    <content><![CDATA[<h4 id="一、事务："><a href="#一、事务：" class="headerlink" title="一、事务："></a><strong>一、事务：</strong></h4><ul>
<li><strong>原子性：</strong>事务包含的操作要么全部成功，要么全部失败回滚。</li>
<li><strong>一致性：</strong>事务执行前后都必须处于一个一致性状态。</li>
<li><strong>隔离性：</strong>多事务并发执行，任一事务更新操作到成功提交的过程，对其他事务都是不可见的。</li>
<li><strong>持久性：</strong>事务一经提交，对数据库数据的改变是永久性的。</li>
</ul>
<h4 id="二、寄存器："><a href="#二、寄存器：" class="headerlink" title="二、寄存器："></a><strong>二、寄存器：</strong></h4><ul>
<li><strong>程序计数器：</strong>存放指令地址。</li>
<li><strong>状态寄存器：</strong>记录运算中产生的标志信息。</li>
<li><strong>通用寄存器：</strong>运算时暂存操作数、地址。</li>
<li><strong>累加器：</strong>数据寄存器，运算中暂存操作数和中间结果，数据不长存。</li>
</ul>
<blockquote>
<p>CPU在<strong>一个总线周期</strong>结束时响应DMA请求。<br><strong>加法器</strong>是算术逻辑单元的部件。<br>在程序执行过程中，cache与主存的地址映像由<strong>硬件自动完成</strong>。<br>补码自带符号位，0是唯一的，n位二进制编码可以表示<strong>2<sup>n</sup><strong>个不同的数。<br>浮点数表示为阶和尾数两部分。两浮点数相加，先对阶，即</strong>将小阶向大阶对其，同时将尾数右移n位</strong>。<br>指令寄存器位数取决于<strong>指令字长</strong>。<br>为了便于多级中断，使用<strong>堆栈</strong>保护断点和现场最有效。</p>
</blockquote>
<h4 id="三、存储器分类："><a href="#三、存储器分类：" class="headerlink" title="三、存储器分类："></a><strong>三、存储器分类：</strong></h4><ul>
<li><strong>位置：</strong>内存、外存。</li>
<li><strong>材料：</strong>磁存储器、半导体存储器、光存储器。</li>
<li><strong>工作方式：</strong>读写存储器、只读存储器。</li>
<li><strong>访问方式：</strong>按地址访问、按内容访问。</li>
<li><strong>寻址方式：</strong>随机存储器、顺序存储器、直接存储器。</li>
</ul>
<h4 id="四、指令集："><a href="#四、指令集：" class="headerlink" title="四、指令集："></a><strong>四、指令集：</strong></h4><ol>
<li><strong>概念：</strong><ul>
<li><strong>RISC（Reduced Instruction Set Computer）</strong>：即精简指令集计算机。它的设计理念是通过简化指令系统，使计算机的硬件结构更简单、更规则。指令集的指令数量较少，格式相对简单且长度固定，每条指令的执行时间较短。</li>
<li><strong>CISC（Complex Instruction Set Computer）</strong>：是复杂指令集计算机。它的指令系统较为复杂，包含大量不同功能和复杂程度的指令，指令格式多样，长度可变，能完成复杂多样的操作。</li>
</ul>
</li>
<li><strong>指令特点：</strong><ul>
<li><strong>RISC：</strong><ul>
<li>指令数量通常较少，一般在几十条到一百多条之间。这些指令的功能比较单一，例如加法指令就只进行加法操作。</li>
<li>指令格式简单且固定，有利于指令的快速译码和执行。</li>
</ul>
</li>
<li><strong>CISC：</strong><ul>
<li>指令数量很多，可能包含几百条甚至上千条指令。它有各种功能强大的指令，比如可以一条指令完成从内存中读取数据、进行复杂运算并且存储结果的操作。</li>
<li>指令格式多样且长度可变。这是为了适应各种复杂指令的需求，但也使得指令的译码过程相对复杂，因为硬件需要花费更多时间来识别指令的具体格式和操作内容。</li>
</ul>
</li>
</ul>
</li>
<li><strong>性能特点：</strong><ul>
<li><strong>RISC：</strong><ul>
<li>由于指令简单、格式固定，RISC 处理器可以采用流水线技术来高效地执行指令。</li>
<li>执行速度通常较快，尤其是对于简单、重复的任务，如数值计算等。</li>
</ul>
</li>
<li><strong>CISC：</strong><ul>
<li>CISC 处理器的优势在于可以用较少的指令完成复杂的任务。例如在处理复杂的图形绘制或者文件系统操作时，它可以通过一条复杂指令完成多个简单指令的功能，从而减少程序的指令数量。</li>
<li>但是，由于指令复杂，其执行速度可能会受到影响。复杂指令的译码和执行需要更多的硬件资源和时间，而且指令长度可变也会对指令读取和存储产生一定的干扰。</li>
</ul>
</li>
</ul>
</li>
<li><strong>硬件实现复杂度：</strong><ul>
<li><strong>RISC：</strong><ul>
<li>硬件结构相对简单。因为指令集简单，处理器的控制单元设计比较规则，不需要复杂的微代码（微代码是一种用于解释和执行复杂指令的底层代码）生成电路。例如，在 RISC 处理器中，控制单元可以通过简单的逻辑电路来直接控制指令的执行流程。</li>
<li>寄存器数量通常较多，这有助于提高数据的处理速度。数据可以快速地存储在寄存器中，减少了频繁访问内存的次数，因为访问寄存器比访问内存要快得多。</li>
</ul>
</li>
<li><strong>CISC：</strong><ul>
<li>硬件实现复杂。由于指令集复杂，CISC 处理器需要复杂的控制单元和微代码生成电路来处理各种不同类型的指令。这些电路的设计和实现难度较大，需要更多的芯片面积和功耗。</li>
<li>寄存器数量可能相对较少，因为一些复杂指令可以直接在内存和运算单元之间进行操作，对寄存器的依赖程度相对较低。</li>
</ul>
</li>
</ul>
</li>
<li><strong>应用场景：</strong><ul>
<li><strong>RISC：</strong><ul>
<li>在嵌入式系统中应用广泛，如手机、平板电脑等移动设备中的处理器。这些设备通常需要高效地处理简单、重复的任务，如音频视频播放、图形显示等，RISC 处理器的快速执行和低功耗特点非常适合这些应用。</li>
<li>也用于高性能计算领域，特别是在处理大量数据的并行计算任务时，RISC 处理器的流水线技术和多核心架构可以发挥优势。</li>
</ul>
</li>
<li><strong>CISC：</strong><ul>
<li>在传统的桌面计算机和服务器中仍然有应用。因为这些系统需要运行各种复杂的软件，包括操作系统、数据库管理系统等，CISC 处理器的复杂指令可以更高效地处理这些软件中的复杂操作。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="五、内存存储容量："><a href="#五、内存存储容量：" class="headerlink" title="五、内存存储容量："></a><strong>五、内存存储容量：</strong></h4><ul>
<li>内存按字节编址，从A1000H–&gt;B13FFH的区域，存储容量为<strong>65KB</strong>。</li>
<li>结束地址与起始地址差值加1为存储单元个数：B13FFH-A1000H+1&#x3D;10400H，转为十进制：65536+1024&#x3D;64KB+1KB&#x3D;65K。</li>
</ul>
<h4 id="六、周期："><a href="#六、周期：" class="headerlink" title="六、周期："></a><strong>六、周期：</strong></h4><ul>
<li>计算机操作的最小时间单位：<strong>时钟周期</strong>。</li>
<li>一个<strong>指令周期</strong>需要多个时钟周期。</li>
<li>一个<strong>机器周期</strong>（CPU周期）完成一个计算机基本操作的时间，需要多个时钟周期。</li>
</ul>
<h4 id="七、CPU-与外设间通信："><a href="#七、CPU-与外设间通信：" class="headerlink" title="七、CPU 与外设间通信："></a><strong>七、CPU 与外设间通信：</strong></h4><ol>
<li><p><strong>程序中断方式：</strong></p>
<ul>
<li><p>某一外设的数据准备就绪后，它“主动”向CPU发出中断请求信号，请求CPU暂时中断目前正在执行的程序转而进行数据交换；</p>
</li>
<li><p>当CPU响应这个中断时，便暂停运行主程序，自动转去执行该设备的中断服务程序；</p>
</li>
<li><p>当中断服务程序执行完毕（数据交换结束）后，CPU又<strong>回到原来的主程序继续执行</strong>。</p>
</li>
</ul>
</li>
<li><p><strong>程序查询方式：</strong></p>
<ul>
<li>CPU 不断地查询外部设备的状态寄存器，以确定设备是否准备好进行数据传输。</li>
<li>例如，在从磁盘读取数据时，CPU 会周期性地检查磁盘控制器的状态位，看数据是否已经准备好被读取。</li>
<li>如果状态位显示数据未准备好，CPU 就继续查询；</li>
<li>如果准备好了，CPU 就开始读取数据。（<strong>CPU 利用率很低</strong>）。</li>
</ul>
</li>
<li><p><strong>直接存储器访问（DMA）方式：</strong></p>
<ul>
<li><p>DMA 控制器可以在不需要 CPU 干预的情况下，直接在外部设备和内存之间进行数据传输。</p>
</li>
<li><p>在传输数据之前，CPU 需要对 DMA 控制器进行初始化，设置好传输的起始地址、数据长度、传输方向等参数。</p>
</li>
<li><p>例如，在从硬盘读取大量数据到内存时，DMA 控制器会接管总线控制权，按照预先设定的参数，将硬盘中的数据直接传输到内存指定区域，期间 CPU 可以去处理其他任务。（<strong>硬件成本相对较高</strong>）。</p>
</li>
</ul>
</li>
<li><p><strong>通道方式：</strong></p>
<ul>
<li><p>通道是一种特殊的处理机，它可以独立于 CPU 执行通道程序，专门负责管理和控制外部设备与内存之间的数据传输。</p>
</li>
<li><p>通道有自己的指令系统，可以理解为是一个 “小 CPU”，用于执行通道程序。</p>
</li>
<li><p>例如，在大型计算机系统中，磁带机的大量数据读写可以由通道来完成。</p>
</li>
<li><p>CPU 将通道程序（包括数据传输的起始地址、长度、操作类型等信息）发送给通道，通道就按照程序指令进行操作，而 CPU 可以去做其他工作。（<strong>硬件和软件实现都比较复杂，成本较高</strong>）。</p>
</li>
</ul>
</li>
</ol>
<h4 id="八、指令流水线："><a href="#八、指令流水线：" class="headerlink" title="八、指令流水线："></a><strong>八、指令流水线：</strong></h4><ol>
<li><p><strong>基本概念：</strong></p>
<ul>
<li>指令流水线是将指令的执行过程分解为多个阶段，如取指（IF）、译码（ID）、执行（EX）、访存（MEM）和写回（WB）等阶段。每个阶段由专门的硬件电路来处理，不同指令的不同阶段可以在同一时间内重叠执行，提高指令的执行效率。</li>
</ul>
</li>
<li><p><strong>计算指标：</strong></p>
<ul>
<li><strong>吞吐率（Throughput）：</strong><ul>
<li><strong>定义</strong>：单位时间内执行的指令数。它是衡量流水线性能的一个重要指标。</li>
<li><strong>计算公式</strong>：吞吐率 $TP&#x3D;\frac{n}{T_k}$，其中 $n$ 是执行的指令数，$T_k$ 是处理 $n$ 条指令所用的时间。在理想情况下（各阶段时间相等且无流水线停顿），如果流水线的时钟周期为 $T$，流水线阶段数为 $k$，则执行 $n$ 条指令的时间 $T_k&#x3D;(k + n - 1)T$，所以理想吞吐率 $TP&#x3D;\frac{n}{(k + n - 1)T}$。当 $n$ 很大时，$TP\approx\frac{1}{T}$。</li>
<li><strong>示例</strong>：假设有一个5阶段（$k &#x3D; 5$）的流水线，时钟周期 $T &#x3D; 1ns$，要执行100条指令（$n &#x3D; 100$）。按照公式计算，$T_k&#x3D;(5 + 100 - 1)\times1ns &#x3D; 104ns$，则吞吐率 $TP&#x3D;\frac{100}{104ns}\approx0.96\times10^9$ 条指令&#x2F;秒。</li>
</ul>
</li>
<li><strong>加速比（Speed - up）：</strong><ul>
<li><strong>定义</strong>：非流水线执行时间与流水线执行时间之比。它反映了流水线相对于非流水线方式在性能上的提升程度。</li>
<li><strong>计算公式</strong>：设非流水线方式执行一条指令的时间为 $T_0$，流水线的时钟周期为 $T$，流水线阶段数为 $k$，则加速比 $S&#x3D;\frac{nT_0}{(k + n - 1)T}$。在理想情况下，当各阶段时间相等且 $T &#x3D; \frac{T_0}{k}$ 时，对于大量指令（$n\gg k$），加速比 $S\approx k$。</li>
<li><strong>示例</strong>：假设非流水线方式执行一条指令需要 $10ns$（$T_0 &#x3D; 10ns$），采用一个4阶段（$k &#x3D; 4$）的流水线，且每个阶段时间相等，那么流水线的时钟周期 $T&#x3D;\frac{10ns}{4}&#x3D;2.5ns$。如果要执行1000条指令（$n &#x3D; 1000$），非流水线执行时间为 $1000\times10ns &#x3D; 10000ns$，流水线执行时间 $T_k&#x3D;(4 + 1000 - 1)\times2.5ns &#x3D; 2507.5ns$，加速比 $S&#x3D;\frac{1000\times10ns}{2507.5ns}\approx3.99$。</li>
</ul>
</li>
<li><strong>效率（Efficiency）：</strong><ul>
<li><strong>定义</strong>：流水线的设备利用率。它是指流水线中各功能段的实际使用时间与整个运行时间之比。</li>
<li><strong>计算公式</strong>：在理想情况下（各阶段时间相等），效率 $E&#x3D;\frac{n}{k(k + n - 1)}$。当 $n$ 很大时，$E\approx\frac{1}{k}$。</li>
<li><strong>示例</strong>：同样是上述4阶段（$k &#x3D; 4$）的流水线，执行1000条指令（$n &#x3D; 1000$），根据公式计算效率 $E&#x3D;\frac{1000}{4\times(4 + 1000 - 1)}\approx0.25$。</li>
</ul>
</li>
</ul>
</li>
<li><p>指令流水线操作周期为“<strong>瓶颈</strong>”段所需时间。（最大操作时间段）。</p>
</li>
</ol>
<h4 id="九、指令执行时间："><a href="#九、指令执行时间：" class="headerlink" title="九、指令执行时间："></a><strong>九、指令执行时间：</strong></h4><ol>
<li><p><strong>顺序方式执行时间计算：</strong></p>
<ul>
<li><p>在<strong>顺序执行</strong>方式下，每条指令都要依次经过取指令、分析和执行这三个阶段，上一条指令执行完所有阶段后，下一条指令才开始执行。</p>
</li>
<li><p><strong>每条指令执行总时间：</strong></p>
</li>
<li><p>执行一条指令时间为取指、分析和执行三个阶段时间之和，即：[4\triangle t + 2\triangle t + 3\triangle t &#x3D; 9\triangle t]</p>
</li>
<li><p><strong>计算600条指令执行总时间：</strong></p>
</li>
<li><p>由于是顺序执行，执行完(600)条指令所需的总时间就是一条指令执行时间乘以指令的条数，即：[9\triangle t×600 &#x3D; 5400\triangle t]</p>
</li>
</ul>
</li>
<li><p><strong>流水线方式执行时间计算：</strong></p>
<ul>
<li><p>在流水线执行方式下，不同指令的不同阶段可以<strong>重叠进行</strong>，就像工厂的流水线一样，各个阶段同时开展工作。</p>
</li>
<li><p><strong>确定流水线的阶段数及各阶段时间：</strong></p>
</li>
<li><p>本题中流水线分为取指令、分析和执行这(3)个阶段，对应的时间分别为(4\triangle t)、(2\triangle t)、(3\triangle t)。</p>
</li>
<li><p><strong>计算第一条指令进入流水线到最后一条指令流出流水线的时间：</strong></p>
<ul>
<li><p>对于流水线，执行(n)条指令所需的总时间可以用公式(T &#x3D; (k + n - 1)×\Delta t_{max})来计算（其中(k)是流水线的阶段数，(n)是指令的条数，(\Delta t_{max})是流水线各阶段中时间最长的那个阶段所用时间）。</p>
</li>
<li><p>在本题中，k &#x3D; 3，n &#x3D; 600，(\Delta t_{max}&#x3D; 4\triangle t)，将这些值代入上述公式可得：<br>$$<br>[T &#x3D; (3 + 600 - 1)×4\triangle t]<br>[&#x3D;(602)×4\triangle t]<br>[&#x3D; 2408\triangle t]<br>$$</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="十、中断响应时间："><a href="#十、中断响应时间：" class="headerlink" title="十、中断响应时间："></a><strong>十、中断响应时间：</strong></h4><ul>
<li>CPU 中断响应时间是指<strong>从 CPU 检测到中断请求信号到开始执行中断服务程序</strong>的第一条指令所需要的时间。</li>
</ul>
<h4 id="十一、机器指令寻址方式："><a href="#十一、机器指令寻址方式：" class="headerlink" title="十一、机器指令寻址方式："></a><strong>十一、机器指令寻址方式：</strong></h4><ol>
<li><strong>立即寻址：</strong><ul>
<li><strong>定义</strong>：操作数直接包含在指令中，作为指令的一部分。</li>
<li><strong>特点和用途</strong>：优点是指令执行速度快，因为不需要额外的访存操作来获取操作数，它常用于给寄存器赋初值等操作。</li>
</ul>
</li>
<li><strong>直接寻址</strong><ul>
<li><strong>定义</strong>：指令的操作数部分直接给出操作数在内存中的地址。</li>
<li><strong>特点和用途</strong>：直接寻址方式简单直观，能直接访问内存中的数据。但是，它只能访问固定的内存单元。</li>
</ul>
</li>
<li><strong>间接寻址</strong><ul>
<li><strong>定义</strong>：指令中给出的是存放操作数地址的存储单元的地址。</li>
<li><strong>特点和用途</strong>：这种寻址方式增加了地址的灵活性。通过改变存放操作数地址的寄存器内容，可以方便地访问不同的内存单元。</li>
</ul>
</li>
<li><strong>寄存器寻址</strong><ul>
<li><strong>定义</strong>：操作数存放在寄存器中，指令直接指定寄存器来获取操作数。</li>
<li><strong>特点和用途</strong>：寄存器寻址的速度非常快，因为寄存器位于CPU内部，数据访问速度比内存快得多。这种寻址方式常用于在CPU内部的寄存器之间进行数据传输和操作。</li>
</ul>
</li>
<li><strong>寄存器间接寻址</strong><ul>
<li><strong>定义</strong>：操作数的地址存放在寄存器中，通过寄存器间接获取操作数的地址。</li>
<li><strong>特点和用途</strong>：结合了寄存器寻址的速度优势和间接寻址的灵活性。它在处理数组和缓冲区等数据结构时非常有用。</li>
</ul>
</li>
<li><strong>相对寻址</strong><ul>
<li><strong>定义</strong>：以程序计数器（PC）或指令指针（IP）的当前内容为基地址，加上指令中给出的偏移量来形成操作数的有效地址。</li>
<li><strong>特点和用途</strong>：主要用于程序的分支和循环结构中。它的优点是代码的可移植性较好，因为相对地址不依赖于程序在内存中的绝对位置。</li>
</ul>
</li>
<li><strong>基址寻址</strong><ul>
<li><strong>定义</strong>：将CPU中的基址寄存器（如8086中的BX或BP）的内容与指令中给定的偏移量相加，得到操作数的地址。</li>
<li><strong>特点和用途</strong>：可以方便地访问一片连续的内存区域。这种寻址方式常用于访问数组、结构体等数据结构，其中基址寄存器可以指向数据结构的起始地址，偏移量用于访问内部的元素。</li>
</ul>
</li>
<li><strong>变址寻址</strong><ul>
<li><strong>定义</strong>：以变址寄存器（如8086中的SI或DI）的内容为基础，加上指令中给定的偏移量来确定操作数的地址。</li>
<li><strong>特点和用途</strong>：与基址寻址类似，变址寻址也用于访问连续的内存区域。它的特点是变址寄存器的内容可以在程序执行过程中动态变化，常用于循环访问数组元素。</li>
</ul>
</li>
</ol>
<h4 id="十二、Flynn分类法："><a href="#十二、Flynn分类法：" class="headerlink" title="十二、Flynn分类法："></a><strong>十二、Flynn分类法：</strong></h4><p>Flynn于1972年提出计算平台分类法主要根据指令流和数据流来分类，分为四类：</p>
<ol>
<li><p><strong>单指令流单数据流机器（S1SD)：</strong></p>
<ul>
<li>SISD机器是一种传统的串行计算机，它的硬件不支持任何形式的并行计算，所有的指令都是串行执行。并且在某个时钟周期内，CPU只能处理一个数据流。</li>
</ul>
</li>
<li><p><strong>单指令流多数据流机器（SIMD)：</strong></p>
<ul>
<li>SIMD是采用一个指令流处理多个数据流。这类机器在数字信号处理、图像处理，以及多媒体信息处理等领域非常有效。</li>
<li>Intel处理器实现的MMXTM、SSE (Streaming SIMD Extensions)、SSE2及SSE3扩展指令集，都能在单个时钟周期内处理多个数据单元。也就是说人们现在用的单核计算机基本上都属于SIMD机器。</li>
</ul>
</li>
<li><p><strong>多指令流单数据流机器(MISD)：</strong></p>
<ul>
<li>MISD采用多指令流处理单个数据流。实际情况中，用多指令流处理多数据流才是更有效的方法，因此MISD只作为理论模型出现，没投入实际应用。</li>
</ul>
</li>
<li><p><strong>多指令流多数据流机器(MIMD)：</strong></p>
<ul>
<li>MIMD机器可以同时执行多个指令流，这些指令流分别对不同数据流进行操作。</li>
</ul>
</li>
</ol>
<h4 id="十三、图像数据量："><a href="#十三、图像数据量：" class="headerlink" title="十三、图像数据量："></a><strong>十三、图像数据量：</strong></h4><ol>
<li><p><strong>计算数据量的公式：</strong></p>
<ul>
<li>图像数据量 &#x3D; 图像水平分辨率×图像垂直分辨率×像素深度（单位为位）÷ 8（单位转换为字节）。<ul>
<li><strong>图像水平分辨率和垂直分辨率</strong>：分别表示图像在水平和垂直方向上所包含的像素数量。</li>
<li><strong>像素深度</strong>：指存储每个像素所用的位数。对于真彩色图像，像素深度为24位（因为每个像素有3个基色分量，每个分量8位）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>计算示例</strong></p>
<ul>
<li><p>假设有一幅真彩色图像：800<em>600px，像素深度为24位，根据上述公式计算其数据量：<br>$$<br>[<br>\begin{align</em>}<br>&amp;800×600×24÷8\<br>&#x3D;&amp;800×600×3\<br>&#x3D;&amp;480000×3\<br>&#x3D;&amp;1440000字节<br>\end{align*}<br>]</p>
<p>[1440000÷1024÷1024≈1.37MB]<br>$$</p>
</li>
</ul>
</li>
</ol>
<h4 id="十四、CPI、MIPS、PCI、MFLOPS："><a href="#十四、CPI、MIPS、PCI、MFLOPS：" class="headerlink" title="十四、CPI、MIPS、PCI、MFLOPS："></a><strong>十四、CPI、MIPS、PCI、MFLOPS：</strong></h4><ul>
<li><p><strong>CPI（Cycles Per Instruction）：</strong>每条指令执行所需的时钟周期数。它是衡量计算机性能的一个重要指标，反映了CPU执行指令的效率。<br>$$<br>CPI &#x3D; \frac{CPU执行程序所用的时钟周期数}{程序包含的指令数}<br>$$</p>
</li>
<li><p><strong>MIPS（Million Instructions Per Second）：</strong>表示计算机在一秒钟内能够执行的指令数量，单位是百万条指令&#x2F;秒。用于衡量计算机的运算速度。<br>$$<br>MIPS &#x3D; \frac{指令数}{执行时间\times10^{6}}<br>$$</p>
</li>
<li><p><strong>PCI（Peripheral Component Interconnect）：</strong>外围部件互连，是一种计算机局部总线标准。</p>
<table>
<thead>
<tr>
<th>PCIe版本</th>
<th>单通道传输速率（GT&#x2F;s）</th>
<th>编码方式</th>
<th>单通道有效数据传输速率（Gbps）</th>
<th>x16模式总带宽（Gbps）</th>
</tr>
</thead>
<tbody><tr>
<td>1.0</td>
<td>2.5</td>
<td>8b&#x2F;10b</td>
<td>2</td>
<td>32</td>
</tr>
<tr>
<td>2.0</td>
<td>5</td>
<td>8b&#x2F;10b</td>
<td>4</td>
<td>64</td>
</tr>
<tr>
<td>3.0</td>
<td>8</td>
<td>128b&#x2F;130b</td>
<td>约7.88</td>
<td>约126</td>
</tr>
<tr>
<td>4.0</td>
<td>16</td>
<td>128b&#x2F;130b</td>
<td>约15.75</td>
<td>约252</td>
</tr>
<tr>
<td>5.0</td>
<td>32</td>
<td>128b&#x2F;130b</td>
<td>约30.5</td>
<td>约488</td>
</tr>
<tr>
<td>6.0</td>
<td>64</td>
<td>新编码和信号传输技术</td>
<td>大幅提升</td>
<td>-</td>
</tr>
</tbody></table>
</li>
<li><p><strong>MFLOPS（Million Floating - Point Operations Per Second）：</strong>每秒百万次浮点运算数，主要用于衡量计算机在浮点运算方面的性能。<br>$$<br>MFLOPS &#x3D; \frac{浮点运算次数}{执行时间\times10^{6}}<br>$$</p>
</li>
</ul>
<h4 id="十五、WLAN标准："><a href="#十五、WLAN标准：" class="headerlink" title="十五、WLAN标准："></a><strong>十五、WLAN标准：</strong></h4><table>
<thead>
<tr>
<th>标准</th>
<th>频段</th>
<th>最大数据速率</th>
<th>调制方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>802.11a</td>
<td>5GHz</td>
<td>54Mbps</td>
<td>OFDM（正交频分复用）</td>
<td>传输速率较高，但传输距离相对较短，受障碍物影响较大，频段干扰相对较少</td>
</tr>
<tr>
<td>802.11b</td>
<td>2.4GHz</td>
<td>11Mbps</td>
<td>DSSS（直接序列扩频）</td>
<td>传输距离较远，但速率较低，频段容易受到干扰，是早期广泛使用的标准之一</td>
</tr>
<tr>
<td>802.11g</td>
<td>2.4GHz</td>
<td>54Mbps</td>
<td>OFDM（正交频分复用）</td>
<td>与802.11b兼容，在2.4GHz频段实现了较高的数据传输速率，应用较为广泛</td>
</tr>
<tr>
<td>802.11n</td>
<td>2.4GHz和5GHz</td>
<td>600Mbps</td>
<td>MIMO - OFDM（多输入多输出 - 正交频分复用）</td>
<td>采用MIMO技术，提高了传输速率和传输距离，同时在两个频段都能工作，兼容性较好</td>
</tr>
<tr>
<td>802.11ac</td>
<td>5GHz</td>
<td>理论上可达6.93Gbps（实际应用中速率因多种因素降低）</td>
<td>OFDM（正交频分复用）等高级调制技术</td>
<td>主要工作在5GHz频段，进一步提高了传输速率，支持更宽的频带和更多的空间流，适合高清视频传输等高速应用场景</td>
</tr>
<tr>
<td>802.11ax（Wi - Fi 6）</td>
<td>2.4GHz和5GHz</td>
<td>理论上可达9.6Gbps</td>
<td>OFDMA（正交频分多址）等新技术</td>
<td>采用新技术提升频谱效率、降低延迟，支持更多设备同时连接，在密集用户环境下性能出色，适用于智能家居等多设备场景</td>
</tr>
<tr>
<td>802.11be（Wi - Fi 7）</td>
<td>2.4GHz、5GHz和6GHz</td>
<td>理论上可达46Gbps</td>
<td>进一步优化的调制和多址接入技术</td>
<td>新增6GHz频段资源，提供更高的传输速率、更低的延迟和更好的可靠性，有望满足未来虚拟现实、8K视频等高带宽需求应用</td>
</tr>
</tbody></table>
<h4 id="十六、微波："><a href="#十六、微波：" class="headerlink" title="十六、微波："></a><strong>十六、微波：</strong></h4><table>
<thead>
<tr>
<th>微波分类</th>
<th>频率范围</th>
<th>波长范围</th>
<th>频带名称</th>
<th>应用场景</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>分米波（UHF）</td>
<td>300MHz - 3GHz</td>
<td>1m - 10cm</td>
<td>特高频（Ultra - High Frequency）</td>
<td>广播电视信号传输、移动通信（如GSM网络部分频段）、无绳电话</td>
<td>传播特性近似于光波，沿直线传播，绕射能力弱，但在建筑物内的穿透能力相对较好；能被电离层反射，受气象条件影响相对较小</td>
</tr>
<tr>
<td>厘米波（SHF）</td>
<td>3GHz - 30GHz</td>
<td>10cm - 1cm</td>
<td>超高频（Super - High Frequency）</td>
<td>卫星通信、雷达（如气象雷达、防空雷达）、无线局域网（如Wi - Fi 5GHz频段）</td>
<td>频率较高，带宽较宽，能实现较高的数据传输速率；方向性好，能量集中，但传播损耗比分米波大，易受雨雾等天气影响</td>
</tr>
<tr>
<td>毫米波（EHF）</td>
<td>30GHz - 300GHz</td>
<td>1cm - 1mm</td>
<td>极高频（Extremely - High Frequency）</td>
<td>5G毫米波通信、高速短距离通信（如部分短距数据传输设备）、毫米波雷达（用于汽车自动驾驶等）</td>
<td>频带宽，可利用的频谱资源丰富；波束窄，方向性极强，可实现高精度的定位和探测；但传播损耗大，传输距离短，对障碍物遮挡非常敏感</td>
</tr>
<tr>
<td>丝米波</td>
<td>300GHz - 3THz</td>
<td>1mm - 0.1mm</td>
<td>太赫兹（Terahertz）</td>
<td>安检成像（如人体安检仪）、材料无损检测、高速通信（实验阶段）</td>
<td>位于毫米波和红外线之间的频段，兼具两者部分特性；具有高穿透性和高分辨率成像能力，但技术实现难度较大，信号衰减较为严重</td>
</tr>
</tbody></table>
<h4 id="十七、CRC校验（循环冗余校验）："><a href="#十七、CRC校验（循环冗余校验）：" class="headerlink" title="十七、CRC校验（循环冗余校验）："></a><strong>十七、CRC校验（循环冗余校验）：</strong></h4><ol>
<li><p><strong>基本原理：</strong></p>
<ul>
<li><p>CRC校验是一种基于多项式除法的错误检测方法。发送方和接收方事先约定一个生成多项式（如CRC - 16、CRC - 32等）。发送方将待发送的数据看成一个多项式的系数序列，用这个数据多项式除以生成多项式，得到的余数就是CRC校验码。将校验码附加在原始数据后面一起发送。</p>
</li>
<li><p>例如，对于一个简单的生成多项式$G(x)&#x3D;x^3 + x + 1$（对应的二进制数为1011），假设要发送的数据为1010。将1010看作多项式$M(x)&#x3D;x^3 + x$，在数据后面添加3个0（因为生成多项式最高次幂为3），得到1010000。用1010000除以1011（模2除法），得到余数为011，这个011就是CRC校验码。发送的数据就是1010011。</p>
</li>
</ul>
</li>
<li><p><strong>计算步骤：</strong></p>
<ul>
<li><p><strong>步骤一：确定生成多项式和数据多项式</strong>。根据应用场景和通信协议选择生成多项式，将发送的数据表示为多项式形式。</p>
</li>
<li><p><strong>步骤二：数据多项式左移</strong>。将数据多项式左移生成多项式最高次幂的位数，在低位补0。</p>
</li>
<li><p><strong>步骤三：进行模2除法</strong>。用左移后的多项式除以生成多项式，模2除法的规则是减法不借位，即异或运算。</p>
</li>
<li><p><strong>步骤四：得到校验码和发送数据</strong>。除法运算得到的余数就是CRC校验码，将校验码附加在原始数据后面作为发送数据。</p>
</li>
</ul>
</li>
<li><p><strong>校验过程：</strong></p>
<ul>
<li>接收方收到数据后，用接收到的数据（包括原始数据和CRC校验码）除以相同的生成多项式。如果余数为0，则认为数据没有错误；如果余数不为0，则说明数据在传输过程中出现了错误。</li>
</ul>
</li>
<li><p><strong>应用场景：</strong></p>
<ul>
<li>CRC校验广泛应用于数据存储和数据通信领域。在数据存储中，如硬盘、U盘等存储设备写入数据时计算CRC校验码，读取数据时进行校验，以检测数据是否因存储介质损坏等原因出现错误。在数据通信中，像以太网、蓝牙等通信协议都使用CRC校验来检测传输过程中的数据错误，确保数据的完整性。</li>
</ul>
</li>
</ol>
<h4 id="十八、二进制指数退避算法："><a href="#十八、二进制指数退避算法：" class="headerlink" title="十八、二进制指数退避算法："></a><strong>十八、二进制指数退避算法：</strong></h4><ol>
<li><p><strong>基本原理：</strong></p>
<ul>
<li><p>二进制指数退避算法主要用于解决在共享介质（如以太网）的网络环境中，多个设备同时发送数据产生冲突后的重发问题。当发生冲突时，每个发送设备随机选择一个等待时间，这个等待时间是一个时隙（时间片）的整数倍，时隙的大小是固定的。</p>
</li>
<li><p>例如，第一次发生冲突后，设备随机选择等待0或1个时隙后重发；如果再次冲突，就随机选择等待0、1、2或3个时隙后重发；每冲突一次，等待时间的上限就成倍增加，这个倍数是2的指数形式，所以称为二进制指数退避。</p>
</li>
</ul>
</li>
<li><p><strong>计算步骤：</strong></p>
<ul>
<li><p><strong>步骤一：确定冲突次数</strong>。设备检测到发送数据时发生冲突的次数。</p>
</li>
<li><p><strong>步骤二：计算等待时隙范围</strong>。根据冲突次数$n$，计算等待时隙的范围是$[0,2^n - 1]$。例如，第一次冲突$n &#x3D; 1$，等待时隙范围是$[0,1]$；第二次冲突$n &#x3D; 2$，范围是$[0,3]$。</p>
</li>
<li><p><strong>步骤三：随机选择等待时间</strong>。在计算出的等待时隙范围内随机选择一个值$k$，设备等待$k$个时隙后再尝试发送数据。</p>
</li>
</ul>
</li>
<li><p><strong>应用场景：</strong></p>
<ul>
<li>该算法主要应用于以太网等采用CSMA&#x2F;CD（载波监听多路访问&#x2F;冲突检测）协议的网络中。在这种网络环境下，多个节点共享传输介质，通过二进制指数退避算法可以有效减少冲突的再次发生概率，提高网络的稳定性和传输效率。例如，在一个办公室的局域网中，多台计算机通过以太网连接到交换机，当计算机同时发送数据产生冲突时，就会使用二进制指数退避算法来重发数据。</li>
</ul>
</li>
</ol>
<h4 id="十九、ipconfig参数表格："><a href="#十九、ipconfig参数表格：" class="headerlink" title="十九、ipconfig参数表格："></a><strong>十九、ipconfig参数表格：</strong></h4><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>/all</code></td>
<td align="left">显示完整的TCP&#x2F;IP配置信息，包括IP地址、子网掩码、默认网关、DNS服务器地址、物理（MAC）地址等所有网络适配器的详细信息。</td>
</tr>
<tr>
<td align="center"><code>/release</code></td>
<td align="left">释放通过DHCP（动态主机配置协议）获取的IP地址。</td>
</tr>
<tr>
<td align="center"><code>/renew</code></td>
<td align="left">向DHCP服务器请求更新IP地址。通常在使用<code>/release</code>释放IP地址后，或者当网络连接出现异常需要重新获取有效的IP配置时使用。</td>
</tr>
<tr>
<td align="center"><code>/flushdns</code></td>
<td align="left">清除本地DNS缓存。</td>
</tr>
<tr>
<td align="center"><code>/displaydns</code></td>
<td align="left">显示本地DNS缓存的内容。用于查看当前系统缓存的DNS记录，了解哪些域名已经被解析并存储在本地缓存中。</td>
</tr>
</tbody></table>
<h4 id="二十、RAID："><a href="#二十、RAID：" class="headerlink" title="二十、RAID："></a><strong>二十、RAID：</strong></h4><table>
<thead>
<tr>
<th align="center">RAIA级别</th>
<th align="left"><strong>特点</strong></th>
<th align="center">磁盘利用率</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RAID 0</td>
<td align="left">数据条带化分布在多个磁盘上，无数据冗余，读写效率高，但一个磁盘损坏会导致所有数据丢失。<br>最少需要两块盘。</td>
<td align="center">100%</td>
</tr>
<tr>
<td align="center">RAID 1</td>
<td align="left">将数据同时写入两个或多个磁盘，实现数据完全镜像备份，提供高数据冗余，但磁盘利用率低，写性能相对较差。<br>最少需要两块盘，盘数需为偶数。</td>
<td align="center">50%</td>
</tr>
<tr>
<td align="center">RAID 3</td>
<td align="left">一块盘单独做奇偶校验盘，其余盘做RAID 0，数据以位或字节为单位分散存储在数据盘中，校验盘用于存储奇偶校验信息。<br>读写效率高，一定程度上提供数据冗余，但校验盘损坏后无法恢复数据。<br>最少需要三块盘。</td>
<td align="center">$(n - 1) &#x2F; n$，其中$n$为磁盘总数，当$n &#x3D; 3$时，利用率约为66.7%</td>
</tr>
<tr>
<td align="center">RAID 5</td>
<td align="left">数据和奇偶校验数据分布在所有磁盘上，以块为单位进行条带化存储，最多允许坏一块盘，通过奇偶校验信息恢复数据。<br>读写性能较好，读性能优于写性能，磁盘利用率较高。<br>最少需要三块盘。</td>
<td align="center">$(n - 1) &#x2F; n$，例如，当有5块磁盘时，磁盘利用率为80%</td>
</tr>
<tr>
<td align="center">RAID 6</td>
<td align="left">在RAID 5的基础上增加了一种校验码，最多允许坏两块盘，数据安全性更高，但性能相对较低，写性能比RAID 5更差。<br>最少需要四块盘。</td>
<td align="center">$(n - 2) &#x2F; n$，比如，当有6块磁盘时，磁盘利用率约为66.7%</td>
</tr>
<tr>
<td align="center">RAID 10</td>
<td align="left">先进行镜像，再进行条带化，结合了RAID 0的高读写性能和RAID 1的数据冗余优势，允许一半的磁盘（每组镜像中的一个）损坏而不丢失数据。<br>最少需要四块盘，盘数必须是偶数。</td>
<td align="center">50%</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>网工</category>
      </categories>
      <tags>
        <tag>网络工程师</tag>
        <tag>考试知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>About</title>
    <url>https://dcyyd.github.io/hexo_websites/2020/11/24/about/</url>
    <content><![CDATA[<h3 id="个人简介"><a href="#个人简介" class="headerlink" title="个人简介"></a>个人简介</h3><hr>
<ul>
<li><p>我是<strong>窦长友</strong>，一名摄影爱好者，编程小渣渣~~</p>
</li>
<li><p>目前就读于<strong>开封大学</strong>….</p>
</li>
</ul>
<h3 id="我的爱好"><a href="#我的爱好" class="headerlink" title="我的爱好"></a>我的爱好</h3><hr>
<p>热衷于研究所有与计算机相关的事物，包括：</p>
<ul>
<li><p><strong>摄影修图</strong>：通过各种软件和技巧来让拍摄的照片更加完美。 </p>
</li>
<li><p><strong>视频编辑</strong>：对拍摄的视频素材进行剪辑、添加特效等操作，使其成为富有吸引力的视频作品。 </p>
</li>
<li><p><strong>PPT设计</strong>：精心构思PPT的内容结构、排版以及动画效果等，打造出高质量的演示文稿。</p>
</li>
<li><p><strong>网页设计</strong>：从页面布局、色彩搭配到交互功能等方面进行设计，创建美观实用的网页。</p>
</li>
</ul>
<h3 id="我的白日梦"><a href="#我的白日梦" class="headerlink" title="我的白日梦"></a>我的白日梦</h3><hr>
<p>带着相机和好心情，与自己喜欢的人一起环游世界。</p>
<p>要是大家有什么好的建议，欢迎告知呀！</p>
]]></content>
      <categories>
        <category>About</category>
      </categories>
      <tags>
        <tag>about</tag>
        <tag>关于我</tag>
      </tags>
  </entry>
  <entry>
    <title>基于GitHub+hexo部署静态Blog</title>
    <url>https://dcyyd.github.io/hexo_websites/2024/12/07/%E5%9F%BA%E4%BA%8EGitHub-hexo%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81Blog/</url>
    <content><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>本文详细介绍了如何使用Hexo框架搭建一个个人博客，并将其部署到GitHub Pages上。主要内容包括：</p>
<ul>
<li><strong>环境准备：</strong>安装Node.js和Git</li>
<li><strong>配置Git和GitHub：</strong>设置SSH密钥，创建GitHub仓库</li>
<li><strong>初始化Hexo项目：</strong>安装Hexo，创建新博客</li>
<li><strong>部署到GitHub Pages：</strong>配置部署设置，推送静态文件</li>
<li><strong>基本使用方法：</strong>创建新文章，本地预览，发布更新</li>
</ul>
<p>这个教程适合那些想要快速搭建个人博客，但又不想花费太多成本的人。通过使用Hexo和GitHub的免费服务，您可以轻松创建一个高效、简洁的博客网站。</p>
<h3 id="二、事前准备"><a href="#二、事前准备" class="headerlink" title="二、事前准备"></a><strong>二、事前准备</strong></h3><ol>
<li><h4 id="在线支持"><a href="#在线支持" class="headerlink" title="在线支持"></a><strong>在线支持</strong></h4><ul>
<li><a href="https://app.rainyun.com/"><strong>域名注册 | 雨云</strong></a>：（非必须，你也可以使用免费域名，或者<code>GitHub.io</code>或<code>Pages.dev</code>分配的域名也可以）</li>
<li><a href="https://github.com/"><strong>GitHub</strong></a>：（必须，你需要注册一个 GitHub 帐号）</li>
</ul>
</li>
<li><h4 id="软件支持"><a href="#软件支持" class="headerlink" title="软件支持"></a><strong>软件支持</strong></h4><ul>
<li><a href="https://blog.kingxujw.com/2024/10/07/%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/#2-1-%E5%AE%89%E8%A3%85-Node"><strong>Node</strong></a>：（必须，Nodejs 是一个基于<strong>Chrome V8</strong>引擎的<strong>JS</strong>运行环境，可以用<strong>JS</strong>写服务器和前端代码。）</li>
<li><a href="https://blog.kingxujw.com/2024/10/07/%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/#2-2-%E5%AE%89%E8%A3%85-Git"><strong>Git</strong></a>：（必须，Git 是当前最先进、最主流的<strong>分布式</strong>版本控制系统，免费、开源）</li>
<li><a href="https://gohugo.io/"><strong>Hugo</strong></a>：（必须，Hugo 是用<strong>Go</strong>语言写的静态网站生成器（Static Site Generator），可以把 Markdown 文件转化成 HTML 文件）</li>
<li><a href="https://dcloud.io/hbuilderx.html"><strong>HBuilderX</strong></a>：（非必须，HBuilderX 是一款为<strong>Vue</strong>开发精心打造的超强集成开发环境（<strong>IDE</strong>））</li>
</ul>
</li>
</ol>
<h3 id="三、软件安装"><a href="#三、软件安装" class="headerlink" title="三、软件安装"></a><strong>三、软件安装</strong></h3><ol>
<li><h4 id="安装-Node"><a href="#安装-Node" class="headerlink" title="安装 Node"></a><strong>安装 Node</strong></h4><ul>
<li><p>打开<a href="https://nodejs.org/zh-cn/download/prebuilt-installer"><strong>Node.js</strong></a>官网，下载和自己系统相配的Node的安装程序，否则会出现安装问题</p>
</li>
<li><p>下载后安装，安装的目录可以使用默认目录<code>C:/Program Files/nodejs/</code></p>
</li>
<li><p>安装完成后，检查是否安装成功。在键盘按下win + R键，输入CMD，然后回车，打开CMD窗口，执行<code>node -v</code>命令，看到版本信息，则说明安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;node -v</span><br><span class="line">v20.18.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改npm源。npm下载各种模块，默认是从国处服务器下载，速度较慢，建议配置成华为云镜像源。打开CMD窗口，运行如下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry https://mirrors.huaweicloud.com/repository/npm/</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h4 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a><strong>安装 Git</strong></h4><ul>
<li><p>进入<a href="https://git-scm.com/downloads/win"><strong>Git</strong></a>官网下载适合你当前系统的版本</p>
</li>
<li><p>下载后傻瓜式安装Git即可，安装的目录最好使用默认目录<code>C:/Program Files/Git</code></p>
</li>
<li><p>按win + R键，输入CMD，然后回车，打开CMD窗口，执行<code>git -v</code>命令，看到版本信息，则说明安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;git -v</span><br><span class="line">git version 2.42.0.windows.2</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Git组件：</strong></p>
<p><strong><code>Git CMD</code></strong> 是windows 命令行的指令风格</p>
<p><strong><code>Git Bash</code></strong> 是linux系统的指令风格（建议使用）</p>
<p>**<code>Git GUI</code>**是图形化界面（新手学习不建议使用）</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="四、配置-Git-密钥并连接至-Github"><a href="#四、配置-Git-密钥并连接至-Github" class="headerlink" title="四、配置 Git 密钥并连接至 Github"></a><strong>四、配置 Git 密钥并连接至 Github</strong></h3><ol>
<li><h4 id="常用-Git-命令："><a href="#常用-Git-命令：" class="headerlink" title="常用 Git 命令："></a><strong>常用 Git 命令：</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config -l	//查看所有配置</span><br><span class="line">git config --system --list	//查看系统配置</span><br><span class="line">git config --global --list	//查看用户（全局）配置</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="配置用户名和邮箱："><a href="#配置用户名和邮箱：" class="headerlink" title="配置用户名和邮箱："></a><strong>配置用户名和邮箱：</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="配置公钥连接-Github："><a href="#配置公钥连接-Github：" class="headerlink" title="配置公钥连接 Github："></a><strong>配置公钥连接 Github：</strong></h4><ul>
<li><p><strong>生成ssh公钥</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>id_rsa</code>私钥</p>
<p><code>id_rsa.pub</code>公钥</p>
</blockquote>
</li>
</ul>
<p> 用记事本打开上述图片中的公钥<code>id_rsa.pub</code>，复制里面的内容，然后开始在github中配置ssh密钥。</p>
<ul>
<li><p><strong>将 SSH KEY 配置到 GitHub</strong>  </p>
<ul>
<li>进入github，点击右上角头像 选择<code>settings</code>，进入设置页后选择 <code>SSH and GPG keys</code>，名字随便起，公钥填到<code>Key</code>那一栏。</li>
</ul>
</li>
<li><p><strong>测试连接，输入以下命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T [email protected]</span><br></pre></td></tr></table></figure></li>
</ul>
<p> 第一次连接会提示<code>Are you sure you want to continue connecting (yes/no/[fingerprint])?</code>，输入<code>yes</code>即可<br> 出现连接到账户的信息，说明已经大功告成，至此完成了环境准备工作。</p>
</li>
<li><h4 id="创建GitHub-io仓库"><a href="#创建GitHub-io仓库" class="headerlink" title="创建GitHub.io仓库"></a><strong>创建GitHub.io仓库</strong></h4><ul>
<li><p>注册登录<a href="https://github.com/"><strong>GitHub</strong></a></p>
</li>
<li><p>点击右上角的<code>+</code>按钮，选择<strong>New repository</strong>，创建一个<code>&lt;用户名&gt;.github.io</code>的仓库。</p>
</li>
<li><p>仓库名字的格式必须为：<code>&lt;用户名&gt;.github.io</code> (注意：前缀必须为用户名，此为预览博客需要，后期可修改仓库名)</p>
</li>
<li><p>可见性必须选择 <code>Public</code> 方便第一次部署检查问题，点击 <strong>Creat repository</strong> 进行创建即可</p>
</li>
</ul>
</li>
</ol>
<h3 id="五、初始化-Hexo-博客"><a href="#五、初始化-Hexo-博客" class="headerlink" title="五、初始化 Hexo 博客"></a><strong>五、初始化 Hexo 博客</strong></h3><ol>
<li><p>创建一个文件夹来保存博客源码（我这里选的路径为<code>D:/Hexo-Blog</code>），在文件夹内右键鼠标，选择<code>Open Git Bash here</code></p>
</li>
<li><p>在<code>Git BASH</code>输入如下命令安装 Hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli &amp;&amp; hexo -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;hexo -v</span><br><span class="line">hexo-cli: 4.3.2</span><br><span class="line">os: win32 10.0.22631 undefined</span><br><span class="line">node: 20.18.0</span><br><span class="line">acorn: 8.12.1</span><br><span class="line">ada: 2.9.0</span><br><span class="line">ares: 1.33.1</span><br><span class="line">base64: 0.5.2</span><br><span class="line">brotli: 1.1.0</span><br><span class="line">cjs_module_lexer: 1.4.1</span><br><span class="line">cldr: 45.0</span><br><span class="line">icu: 75.1</span><br><span class="line">llhttp: 8.1.2</span><br><span class="line">modules: 115</span><br><span class="line">napi: 9</span><br><span class="line">nghttp2: 1.61.0</span><br><span class="line">nghttp3: 0.7.0</span><br><span class="line">ngtcp2: 1.1.0</span><br><span class="line">openssl: 3.0.13+quic</span><br><span class="line">simdutf: 5.5.0</span><br><span class="line">tz: 2024a</span><br><span class="line">undici: 6.19.8</span><br><span class="line">unicode: 15.1</span><br><span class="line">uv: 1.46.0</span><br><span class="line">uvwasi: 0.0.21</span><br><span class="line">v8: 11.3.244.8-node.23</span><br><span class="line">zlib: 1.3.0.1-motley-71660e1</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化 Hexo 项目安装相关依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init blog-demo //创建项目</span><br><span class="line">cd blog-demo //切换路径</span><br><span class="line">npm i //安装依赖</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化项目后，<code>blog-demo</code>有如下结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blog-demo</span><br><span class="line">├── node_modules //依赖包</span><br><span class="line">├── scaffolds //生成文章的一些模板</span><br><span class="line">├── source //用来存放你的文章</span><br><span class="line">├── themes //主题</span><br><span class="line">├──.npmignore //发布时忽略的文件（可忽略）</span><br><span class="line">├── _config.landscape.yml //主题的配置文件</span><br><span class="line">├── config.yml //博客的配置文件</span><br><span class="line">└── package.json //项目名称、描述、版本、运行和开发等信息</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令行输入<code>hexo cl &amp;&amp; hexo s</code>启动项目</p>
</li>
<li><p>打开浏览器，输入地址：<a href="http://localhost:4000/"><code>http://localhost:4000/</code></a> ，看到欢迎界面，说明你的博客已经构建成功了。</p>
</li>
</ol>
<h3 id="六、将静态博客挂载到-GitHub-Pages"><a href="#六、将静态博客挂载到-GitHub-Pages" class="headerlink" title="六、将静态博客挂载到 GitHub Pages"></a><strong>六、将静态博客挂载到 GitHub Pages</strong></h3><ol>
<li><p>安装 hexo-deployer-git</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 <code>_config.yml</code> 文件<br>在blog-demo目录下的_config.yml，就是整个Hexo框架的配置文件，详细可参考官方的<a href="https://hexo.io/zh-cn/docs/configuration">配置描述</a><br>修改最后一行的配置，将repository修改为你自己的github项目地址即可，还有分支要改为<code>main</code>代表主分支（注意缩进）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:  </span><br><span class="line">    type: git</span><br><span class="line">    repository: [email protected]:kingmoon3/kingmoon3.github.io.git</span><br><span class="line">    branch: main</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改好配置后，运行如下命令，将代码部署到 GitHub（Hexo三连）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Git BASH终端</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<blockquote>
<p>**<code>hexo clean</code>**：删除之前生成的文件，可以用<code>hexo cl</code>缩写。</p>
<p>**<code>hexo generate</code>**：生成静态文章，可以用<code>hexo g</code>缩写</p>
<p>**<code>hexo deploy</code>**：部署文章，可以用<code>hexo d</code>缩写</p>
</blockquote>
</li>
</ol>
<p><em>注意：deploy时可能要你输入 username 和 password。</em></p>
<p>如果出现 **<code>INFO  Deploy done: git</code>**，则说明部署成功了。</p>
<p>稍等两分钟，打开浏览器访问：<a href="https://你的github用户名.github.io/">https:&#x2F;&#x2F;[你的github用户名].github.io</a> ，这时候我们就可以看到博客内容了。</p>
<h3 id="附：GitHub网站部署常用命令："><a href="#附：GitHub网站部署常用命令：" class="headerlink" title="附：GitHub网站部署常用命令："></a>附：GitHub网站部署常用命令：</h3><ol>
<li><h4 id="Git相关："><a href="#Git相关：" class="headerlink" title="Git相关："></a>Git相关：</h4></li>
</ol>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>git init</code></td>
<td>在当前目录初始化一个Git仓库</td>
<td><code>git init my_project</code>（在<code>my_project</code>目录下初始化仓库）</td>
</tr>
<tr>
<td><code>git clone [url]</code></td>
<td>克隆远程仓库到本地</td>
<td><code>git clone https://github.com/user/repo.git</code>（克隆指定仓库）</td>
</tr>
<tr>
<td><code>git status</code></td>
<td>查看仓库中文件的状态</td>
<td>在仓库目录下执行<code>git status</code>查看文件修改、暂存等状态</td>
</tr>
<tr>
<td><code>git add [file/dir]</code></td>
<td>将文件或目录添加到暂存区</td>
<td><code>git add file.txt</code>（添加单个文件），<code>git add.</code>（添加当前目录下所有文件）</td>
</tr>
<tr>
<td><code>git commit -m &quot;[message]&quot;</code></td>
<td>提交暂存区的内容，并添加提交消息</td>
<td><code>git commit -m &quot;Update README&quot;</code>（提交并添加消息）</td>
</tr>
<tr>
<td><code>git branch</code></td>
<td>查看本地分支列表</td>
<td>执行<code>git branch</code>查看当前仓库的分支情况</td>
</tr>
<tr>
<td><code>git branch [branch - name]</code></td>
<td>创建一个新的本地分支</td>
<td><code>git branch new_branch</code>（创建名为<code>new_branch</code>的分支）</td>
</tr>
<tr>
<td><code>git checkout [branch - name]</code></td>
<td>切换到指定分支</td>
<td><code>git checkout master</code>（切换到<code>master</code>分支）</td>
</tr>
<tr>
<td><code>git merge [branch - name]</code></td>
<td>合并指定分支到当前分支</td>
<td>假设在<code>master</code>分支，<code>git merge feature_branch</code>（合并<code>feature_branch</code>）</td>
</tr>
<tr>
<td><code>git log</code></td>
<td>查看提交历史</td>
<td>执行<code>git log</code>查看之前的提交记录，包括作者、日期、消息等</td>
</tr>
<tr>
<td><code>git remote add [name] [url]</code></td>
<td>添加远程仓库</td>
<td><code>git remote add origin https://github.com/user/repo.git</code>（添加名为<code>origin</code>的远程仓库）</td>
</tr>
<tr>
<td><code>git push [remote - name] [branch - name]</code></td>
<td>将本地分支推送到远程仓库</td>
<td><code>git push origin master</code>（推送<code>master</code>分支到<code>origin</code>）</td>
</tr>
<tr>
<td><code>git pull [remote - name] [branch - name]</code></td>
<td>从远程仓库拉取并合并更新</td>
<td><code>git pull origin master</code>（拉取<code>master</code>分支更新）</td>
</tr>
<tr>
<td><code>git diff [file]</code></td>
<td>查看文件的修改差异</td>
<td><code>git diff file.txt</code>（查看<code>file.txt</code>的修改差异）</td>
</tr>
<tr>
<td><code>git stash</code></td>
<td>暂存当前工作区的修改</td>
<td>在未完成的修改状态下，执行<code>git stash</code>暂存修改</td>
</tr>
<tr>
<td><code>git stash pop</code></td>
<td>恢复暂存的修改</td>
<td>执行<code>git stash pop</code>恢复之前暂存的修改</td>
</tr>
<tr>
<td><code>git tag [tag - name]</code></td>
<td>给当前提交打标签</td>
<td><code>git tag v1.0</code>（给当前提交打<code>v1.0</code>标签）</td>
</tr>
<tr>
<td><code>git show [tag - name]</code></td>
<td>查看标签相关的提交信息</td>
<td><code>git show v1.0</code>查看<code>v1.0</code>标签对应的提交内容</td>
</tr>
</tbody></table>
<ol start="2">
<li><h4 id="Hexo相关："><a href="#Hexo相关：" class="headerlink" title="Hexo相关："></a>Hexo相关：</h4></li>
</ol>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>hexo init [folder]</code></td>
<td>初始化一个 Hexo 项目，可选参数<code>[folder]</code>指定项目文件夹名称。</td>
<td><code>hexo init my-blog</code>（在当前目录下创建名为<code>my-blog</code>的 Hexo 项目）</td>
</tr>
<tr>
<td><code>hexo new [layout] &lt;title&gt;</code></td>
<td>创建一篇新文章，<code>[layout]</code>是布局模板，<code>&lt;title&gt;</code>是文章标题。</td>
<td><code>hexo new post &quot;My New Post&quot;</code>（创建一篇新的<code>post</code>布局的文章）</td>
</tr>
<tr>
<td><code>hexo generate</code>或<code>hexo g</code></td>
<td>生成静态文件。</td>
<td>执行该命令会根据主题模板生成 HTML、CSS、JS 等静态文件到<code>public</code>目录。</td>
</tr>
<tr>
<td><code>hexo server</code>或<code>hexo s</code></td>
<td>启动本地服务器进行预览。</td>
<td>在本地浏览器中输入<code>http://localhost:4000</code>可查看生成的博客效果。</td>
</tr>
<tr>
<td><code>hexo clean</code></td>
<td>清除之前生成的静态文件和缓存。</td>
<td>当遇到生成问题或切换主题后可先执行此命令。</td>
</tr>
<tr>
<td><code>hexo deploy</code>或<code>hexo d</code></td>
<td>部署博客到指定平台。</td>
<td>配置好后执行该命令可将静态文件推送到远程仓库等部署目标。</td>
</tr>
<tr>
<td><code>hexo list &lt;type&gt;</code></td>
<td>列出特定类型的内容，如<code>post</code>（文章）、<code>page</code>（页面）等。</td>
<td><code>hexo list post</code>列出所有文章信息。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>网站部署</category>
      </categories>
      <tags>
        <tag>网站部署</tag>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
